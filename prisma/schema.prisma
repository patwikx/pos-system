datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// --- CORE INFRASTRUCTURE ---

model User {
  id                       String             @id @default(uuid())
  name                     String?
  username                 String?            @unique
  password                 String?
  createdAt                DateTime           @default(now())
  updatedAt                DateTime           @updatedAt
  isActive                 Boolean            @default(false)
  orders                   Order[]
  assignments              UserBusinessUnit[]
  shifts                   Shift[]
  createdPurchaseRequests  PurchaseRequest[]  @relation("RequestorToPR")
  approvedPurchaseRequests PurchaseRequest[]  @relation("ApproverToPR")
  authoredJournalEntries   JournalEntry[]     @relation("AuthoredJournalEntries")
  approvedJournalEntries   JournalEntry[]     @relation("ApprovedJournalEntries")
  createdRequisitions      StockRequisition[] @relation("UserRequests")
  fulfilledRequisitions    StockRequisition[] @relation("UserFulfills")
  voidedOrderItems         OrderItem[]        @relation("VoidedItems")
  processedPayments        Payment[]
}

model Roles {
  id          String             @id @default(uuid())
  role        String             @unique
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  assignments UserBusinessUnit[]
}

model BusinessUnit {
  id                 String              @id @default(uuid())
  name               String
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  userAssignments    UserBusinessUnit[]
  tables             Table[]
  terminals          PosTerminal[]
  menuCategories     MenuCategory[]
  menuItems          MenuItem[]
  inventoryItems     InventoryItem[]
  purchaseOrders     PurchaseOrder[]
  orders             Order[]
  discounts          Discount[]
  shifts             Shift[]
  reservations       Reservation[]
  modifierGroups     ModifierGroup[]
  journalEntries     JournalEntry[]
  accounts           GlAccount[]
  purchaseRequests   PurchaseRequest[]
  vendorBills        VendorBill[]
  invoices           Invoice[]
  bankAccounts       BankAccount[]
  accountingPeriods  AccountingPeriod[]
  inventoryLocations InventoryLocation[]
  financialReport    FinancialReport[]
}

model UserBusinessUnit {
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  businessUnitId String
  businessUnit   BusinessUnit @relation(fields: [businessUnitId], references: [id], onDelete: Cascade)
  roleId         String
  role           Roles        @relation(fields: [roleId], references: [id])
  assignedAt     DateTime     @default(now())

  @@id([userId, businessUnitId])
}

// --- OPERATIONS & INFRASTRUCTURE ---

model PosTerminal {
  id             String       @id @default(uuid())
  name           String
  description    String?
  isActive       Boolean      @default(true)
  businessUnitId String
  businessUnit   BusinessUnit @relation(fields: [businessUnitId], references: [id], onDelete: Cascade)
  orders         Order[]
  shifts         Shift[]
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@index([businessUnitId])
}

model Table {
  id             String        @id @default(uuid())
  name           String
  businessUnitId String
  businessUnit   BusinessUnit  @relation(fields: [businessUnitId], references: [id], onDelete: Cascade)
  status         TableStatus   @default(AVAILABLE)
  orders         Order[]
  reservations   Reservation[]
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
}

enum TableStatus {
  AVAILABLE
  OCCUPIED
  RESERVED
}

model Shift {
  id             String       @id @default(uuid())
  businessUnitId String
  businessUnit   BusinessUnit @relation(fields: [businessUnitId], references: [id])
  userId         String
  user           User         @relation(fields: [userId], references: [id])
  terminalId     String
  terminal       PosTerminal  @relation(fields: [terminalId], references: [id])
  startedAt      DateTime     @default(now())
  endedAt        DateTime?
  startingCash   Float
  endingCash     Float?
  expectedCash   Float?
  cashDifference Float?
  orders         Order[]
  payments       Payment[]
  notes          String?

  @@index([userId, terminalId])
}

// --- CRM & RESERVATIONS ---
model BusinessPartner {
  id            String        @id @default(uuid())
  name          String
  phone         String?       @unique
  email         String?       @unique
  loyaltyPoints Int           @default(0)
  orders        Order[]
  reservations  Reservation[]
  invoices      Invoice[]
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
}

model Reservation {
  id                String          @id @default(uuid())
  businessPartnerId String
  businessPartner   BusinessPartner @relation(fields: [businessPartnerId], references: [id])
  businessUnitId    String
  businessUnit      BusinessUnit    @relation(fields: [businessUnitId], references: [id])
  tableId           String?
  table             Table?          @relation(fields: [tableId], references: [id])
  reservationTime   DateTime
  partySize         Int
  status            String // e.g., "CONFIRMED", "SEATED", "CANCELLED"
  notes             String?
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
}

// --- MENU MANAGEMENT ---

model MenuCategory {
  id             String       @id @default(uuid())
  name           String
  description    String?
  isActive       Boolean      @default(true)
  businessUnitId String
  businessUnit   BusinessUnit @relation(fields: [businessUnitId], references: [id], onDelete: Cascade)
  menuItems      MenuItem[]
  prepStation    String?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@index([businessUnitId])
}

model MenuItem {
  id             String          @id @default(uuid())
  name           String
  description    String?
  price          Float
  imageUrl       String?
  isActive       Boolean         @default(true)
  categoryId     String
  category       MenuCategory    @relation(fields: [categoryId], references: [id])
  businessUnitId String
  businessUnit   BusinessUnit    @relation(fields: [businessUnitId], references: [id], onDelete: Cascade)
  recipe         Recipe?
  orderItems     OrderItem[]
  modifierGroups ModifierGroup[]
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  InvoiceItem    InvoiceItem[]

  @@index([categoryId, businessUnitId])
}

model ModifierGroup {
  id             String       @id @default(uuid())
  name           String // e.g., "Add-Ons", "Sauce Choices"
  businessUnitId String
  businessUnit   BusinessUnit @relation(fields: [businessUnitId], references: [id], onDelete: Cascade)
  menuItems      MenuItem[]
  modifiers      Modifier[]
  createdAt      DateTime     @default(now())
}

model Modifier {
  id              String         @id @default(uuid())
  name            String // e.g., "Extra Bacon", "No Onions"
  priceChange     Float          @default(0)
  modifierGroupId String
  modifierGroup   ModifierGroup  @relation(fields: [modifierGroupId], references: [id], onDelete: Cascade)
  inventoryItemId String?
  inventoryItem   InventoryItem? @relation(fields: [inventoryItemId], references: [id])
  quantityUsed    Float?
  orderItems      OrderItem[]
  createdAt       DateTime       @default(now())
}

model Recipe {
  id          String       @id @default(uuid())
  menuItemId  String       @unique
  menuItem    MenuItem     @relation(fields: [menuItemId], references: [id], onDelete: Cascade)
  recipeItems RecipeItem[]
  description String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
}

model RecipeItem {
  id              String        @id @default(uuid())
  recipeId        String
  recipe          Recipe        @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id])
  quantityUsed    Float

  @@index([recipeId, inventoryItemId])
}

// --- INVENTORY & PURCHASING ---

model InventoryItem {
  id                    String                 @id @default(uuid())
  name                  String
  description           String?
  isActive              Boolean                @default(true)
  businessUnitId        String
  businessUnit          BusinessUnit           @relation(fields: [businessUnitId], references: [id], onDelete: Cascade)
  uomId                 String
  uom                   UoM                    @relation(fields: [uomId], references: [id])
  recipeItems           RecipeItem[]
  stockLevels           InventoryStock[]
  poItems               PurchaseOrderItem[]
  modifiers             Modifier[]
  purchaseRequestItems  PurchaseRequestItem[]
  vendorBillItems       VendorBillItem[]
  stockRequisitionItems StockRequisitionItem[]
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
}

model InventoryStock {
  id              String              @id @default(uuid())
  inventoryItemId String
  inventoryItem   InventoryItem       @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)
  locationId      String
  location        InventoryLocation   @relation(fields: [locationId], references: [id])
  quantityOnHand  Float
  reorderPoint    Float               @default(0)
  updatedAt       DateTime            @updatedAt
  movements       InventoryMovement[]

  @@unique([inventoryItemId, locationId])
}

// UPDATE the InventoryMovement model
model InventoryMovement {
  id                 String            @id @default(uuid())
  inventoryStockId   String
  inventoryStock     InventoryStock    @relation(fields: [inventoryStockId], references: [id])
  type               MovementType
  quantity           Float
  reason             String?
  orderId            String?
  order              Order?            @relation(fields: [orderId], references: [id])
  purchaseOrderId    String?
  purchaseOrder      PurchaseOrder?    @relation(fields: [purchaseOrderId], references: [id])
  stockRequisitionId String?
  stockRequisition   StockRequisition? @relation(fields: [stockRequisitionId], references: [id])
  createdAt          DateTime          @default(now())

  @@index([inventoryStockId])
}

// UPDATE this enum
enum MovementType {
  SALE_DEPLETION // This would now apply to KITCHEN stock
  RECEIVING // From a Purchase Order into the Main Storeroom
  ADJUSTMENT // For stock counts, spoilage
  STOCK_TRANSFER_IN // Transferring items INTO a location
  STOCK_TRANSFER_OUT // Transferring items OUT OF a location
}

model Supplier {
  id             String          @id @default(uuid())
  name           String
  contactPerson  String?
  email          String?
  phone          String?
  purchaseOrders PurchaseOrder[]
  vendorBills    VendorBill[]
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
}

model PurchaseOrder {
  id                 String              @id @default(uuid())
  purchaseRequestId  String              @unique
  purchaseRequest    PurchaseRequest     @relation(fields: [purchaseRequestId], references: [id])
  businessUnitId     String
  businessUnit       BusinessUnit        @relation(fields: [businessUnitId], references: [id])
  supplierId         String
  supplier           Supplier            @relation(fields: [supplierId], references: [id])
  status             String              @default("PENDING")
  items              PurchaseOrderItem[]
  inventoryMovements InventoryMovement[]
  vendorBills        VendorBill[]
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
}

model PurchaseOrderItem {
  id              String        @id @default(uuid())
  poId            String
  po              PurchaseOrder @relation(fields: [poId], references: [id], onDelete: Cascade)
  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id])
  quantity        Float
  unitCost        Float
}

model UoM {
  id             String          @id @default(uuid())
  name           String
  symbol         String
  inventoryItems InventoryItem[]
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
}

// --- SALES & ORDERS ---

model Order {
  id             String              @id @default(uuid())
  businessUnitId String
  businessUnit   BusinessUnit        @relation(fields: [businessUnitId], references: [id])
  tableId        String?
  table          Table?              @relation(fields: [tableId], references: [id])
  userId         String
  user           User                @relation(fields: [userId], references: [id])
  terminalId     String
  terminal       PosTerminal         @relation(fields: [terminalId], references: [id])
  status         OrderStatus         @default(OPEN)
  orderType      String              @default("Dine-In")
  items          OrderItem[]
  movements      InventoryMovement[]
  subTotal       Float
  discountValue  Float               @default(0)
  tax            Float
  totalAmount    Float
  // ADD this field to track the total amount paid so far:
  amountPaid     Float               @default(0)

  // ADD this back-relation:
  payments          Payment[]
  isPaid            Boolean          @default(false)
  discountId        String?
  discount          Discount?        @relation(fields: [discountId], references: [id])
  shiftId           String?
  shift             Shift?           @relation(fields: [shiftId], references: [id])
  businessPartnerId String?
  businessPartner   BusinessPartner? @relation(fields: [businessPartnerId], references: [id])
  invoice           Invoice?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  @@index([tableId, userId, terminalId])
}

enum OrderStatus {
  PREPARING
  SERVED
  PAID
  CANCELLED
  OPEN
}

model OrderItem {
  id             String     @id @default(uuid())
  orderId        String
  order          Order      @relation(fields: [orderId], references: [id], onDelete: Cascade)
  menuItemId     String
  menuItem       MenuItem   @relation(fields: [menuItemId], references: [id])
  quantity       Int
  priceAtSale    Float
  notes          String?
  kdsStatus      KdsStatus  @default(PENDING)
  isVoided       Boolean    @default(false)
  voidedAt       DateTime?
  voidedByUserId String? // The User ID of the manager who approved the void
  voidedByUser   User?      @relation("VoidedItems", fields: [voidedByUserId], references: [id])
  voidReason     String? // e.g., "Customer changed mind", "Mistake"
  modifiers      Modifier[]

  @@index([orderId, menuItemId])
}

model Discount {
  id             String       @id @default(uuid())
  name           String
  description    String?
  type           DiscountType
  value          Float
  isActive       Boolean      @default(true)
  businessUnitId String
  businessUnit   BusinessUnit @relation(fields: [businessUnitId], references: [id], onDelete: Cascade)
  orders         Order[]
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@index([businessUnitId])
}

enum DiscountType {
  PERCENTAGE
  FIXED_AMOUNT
}

// --- FINANCIALS (Double-Entry Accounting Foundation) ---

model GlAccount {
  id              String             @id @default(uuid())
  name            String
  accountNumber   String?
  balance         Float              @default(0)
  accountTypeId   String
  accountType     AccountType        @relation(fields: [accountTypeId], references: [id])
  businessUnitId  String
  businessUnit    BusinessUnit       @relation(fields: [businessUnitId], references: [id], onDelete: Cascade)
  journalLines    JournalEntryLine[]
  vendorBillItems VendorBillItem[]
  billPayments    BillPayment[]
  invoiceItems    InvoiceItem[]
  bankAccount     BankAccount?
  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt

  @@unique([name, businessUnitId])
  @@index([accountTypeId])
}

model AccountType {
  id          String  @id @default(uuid())
  name        String  @unique // e.g., "ASSET", "LIABILITY", "EQUITY", "REVENUE", "EXPENSE"
  description String? // A short explanation of the type

  accounts GlAccount[] // A type can have many accounts
}

model VendorBill {
  id             String       @id @default(uuid())
  supplierId     String
  supplier       Supplier     @relation(fields: [supplierId], references: [id])
  businessUnitId String
  businessUnit   BusinessUnit @relation(fields: [businessUnitId], references: [id])

  purchaseOrderId String?        @unique
  purchaseOrder   PurchaseOrder? @relation(fields: [purchaseOrderId], references: [id])

  billNumber  String // The invoice number from the supplier
  billDate    DateTime
  dueDate     DateTime
  totalAmount Float
  amountPaid  Float    @default(0)
  status      String // e.g., "DRAFT", "AWAITING_PAYMENT", "PAID", "VOID"

  items    VendorBillItem[]
  payments BillPayment[]

  createdAt DateTime @default(now())
}

model VendorBillItem {
  id           String     @id @default(uuid())
  vendorBillId String
  vendorBill   VendorBill @relation(fields: [vendorBillId], references: [id], onDelete: Cascade)

  inventoryItemId String?
  inventoryItem   InventoryItem? @relation(fields: [inventoryItemId], references: [id])

  description String // e.g., "Beef Patties" or "Monthly Rent"
  quantity    Float
  unitCost    Float

  // The expense account this item should be booked to (e.g., "Cost of Goods Sold", "Rent Expense")
  expenseAccountId String
  expenseAccount   GlAccount @relation(fields: [expenseAccountId], references: [id])
}

model BillPayment {
  id           String     @id @default(uuid())
  vendorBillId String
  vendorBill   VendorBill @relation(fields: [vendorBillId], references: [id])

  paymentDate     DateTime
  amount          Float
  paymentMethod   String // e.g., "BANK_TRANSFER", "CHECK", "CASH"
  referenceNumber String?

  // The asset account the payment was made from (e.g., "Operating Bank Account")
  paymentAccountId String
  paymentAccount   GlAccount @relation(fields: [paymentAccountId], references: [id])
  check            Check?
}

// --- FINANCIALS: ACCOUNTS RECEIVABLE (AR) ---

model Invoice {
  id                String          @id @default(uuid())
  businessPartnerId String
  businessPartner   BusinessPartner @relation(fields: [businessPartnerId], references: [id])
  businessUnitId    String
  businessUnit      BusinessUnit    @relation(fields: [businessUnitId], references: [id])

  orderId String? @unique
  order   Order?  @relation(fields: [orderId], references: [id])

  invoiceNumber String   @unique
  invoiceDate   DateTime
  dueDate       DateTime
  totalAmount   Float
  amountPaid    Float    @default(0)
  status        String // e.g., "DRAFT", "SENT", "PAID", "VOID"

  items InvoiceItem[]
}

model InvoiceItem {
  id        String  @id @default(uuid())
  invoiceId String
  invoice   Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  menuItemId String?
  menuItem   MenuItem? @relation(fields: [menuItemId], references: [id])

  description String // e.g., "Catering Service for Event X"
  quantity    Float
  unitPrice   Float

  // The revenue account this should be booked to (e.g., "Catering Revenue")
  revenueAccountId String
  revenueAccount   GlAccount @relation(fields: [revenueAccountId], references: [id])
}

// --- FINANCIALS: BANKING ---

model BankAccount {
  id            String @id @default(uuid())
  name          String // e.g., "BPI Operating Account"
  bankName      String
  accountNumber String

  // The corresponding GL Account for this bank (which will be an ASSET type)
  glAccountId String    @unique
  glAccount   GlAccount @relation(fields: [glAccountId], references: [id])

  businessUnitId String
  businessUnit   BusinessUnit @relation(fields: [businessUnitId], references: [id])

  // For tracking the next check number to be used for this account
  nextCheckNumber Int?
  checks          Check[] // A bank account can have many checks written from it
}

enum JournalEntryStatus {
  DRAFT // The entry is being created and is not yet submitted for approval.
  PENDING_APPROVAL // Submitted and waiting for a manager to review.
  POSTED // Approved and its values are now reflected in the account balances.
  REJECTED // The entry was rejected and will not be posted.
  VOID // A previously posted entry that has been reversed.
}

model JournalEntry {
  id                 String             @id @default(uuid())
  date               DateTime
  description        String
  status             JournalEntryStatus @default(DRAFT)
  authorId           String
  author             User               @relation("AuthoredJournalEntries", fields: [authorId], references: [id])
  approverId         String?
  approver           User?              @relation("ApprovedJournalEntries", fields: [approverId], references: [id])
  approvalDate       DateTime?
  rejectionReason    String?
  businessUnitId     String
  businessUnit       BusinessUnit       @relation(fields: [businessUnitId], references: [id])
  lines              JournalEntryLine[]
  accountingPeriodId String
  accountingPeriod   AccountingPeriod   @relation(fields: [accountingPeriodId], references: [id])
  createdAt          DateTime           @default(now())
}

model JournalEntryLine {
  id             String       @id @default(uuid())
  journalEntryId String
  journalEntry   JournalEntry @relation(fields: [journalEntryId], references: [id], onDelete: Cascade)
  accountId      String
  account        GlAccount    @relation(fields: [accountId], references: [id])
  debit          Float?
  credit         Float?

  @@index([journalEntryId, accountId])
}

model PurchaseRequest {
  id              String                @id @default(uuid())
  prNumber        String                @unique
  businessUnitId  String
  businessUnit    BusinessUnit          @relation(fields: [businessUnitId], references: [id])
  requestorId     String
  requestor       User                  @relation("RequestorToPR", fields: [requestorId], references: [id])
  status          PurchaseRequestStatus @default(PENDING)
  notes           String?
  approverId      String?
  approver        User?                 @relation("ApproverToPR", fields: [approverId], references: [id])
  approvalDate    DateTime?
  rejectionReason String?
  items           PurchaseRequestItem[]
  purchaseOrder   PurchaseOrder?
  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt

  @@index([requestorId, approverId])
}

model PurchaseRequestItem {
  id                String          @id @default(uuid())
  purchaseRequestId String
  purchaseRequest   PurchaseRequest @relation(fields: [purchaseRequestId], references: [id], onDelete: Cascade)
  inventoryItemId   String
  inventoryItem     InventoryItem   @relation(fields: [inventoryItemId], references: [id])
  requestedQuantity Float
  notes             String?
}

enum PurchaseRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

model AccountingPeriod {
  id              String            @id @default(uuid())
  name            String
  startDate       DateTime
  endDate         DateTime
  status          String // "OPEN", "CLOSED"
  businessUnitId  String
  businessUnit    BusinessUnit      @relation(fields: [businessUnitId], references: [id], onDelete: Cascade)
  journalEntries  JournalEntry[]
  FinancialReport FinancialReport[]

  @@unique([startDate, endDate, businessUnitId])
}

enum CheckStatus {
  TO_BE_PRINTED // The check has been created in the system but not yet printed.
  PRINTED // The check has been printed and sent.
  VOIDED // The check was voided and should not be cashed.
  CLEARED // The check has cleared the bank account.
}

model Check {
  id          String @id @default(uuid())
  checkNumber String // Unique check number for the bank account

  payeeName    String // The name of the supplier or business partner
  payeeAddress String?

  amount        Float
  amountInWords String // e.g., "One Thousand Two Hundred Thirty-Four and 56/100"

  date DateTime // The date written on the check
  memo String? // For tracking invoice numbers, etc.

  status CheckStatus @default(TO_BE_PRINTED)

  bankAccountId String
  bankAccount   BankAccount @relation(fields: [bankAccountId], references: [id])

  // A check is the instrument for one specific bill payment
  billPaymentId String      @unique // The @unique enforces a one-to-one relationship
  billPayment   BillPayment @relation(fields: [billPaymentId], references: [id])

  createdAt DateTime @default(now())

  @@unique([bankAccountId, checkNumber]) // Ensures check numbers are not duplicated for the same bank account
}

model InventoryLocation {
  id             String       @id @default(uuid())
  name           String // e.g., "Main Storeroom", "Hot Kitchen Station", "Bar Well"
  businessUnitId String
  businessUnit   BusinessUnit @relation(fields: [businessUnitId], references: [id])

  stockLevels      InventoryStock[] // A location can hold stock of many items
  // --- ADD THESE TWO LINES ---
  requisitionsFrom StockRequisition[] @relation("FromRequisitions")
  requisitionsTo   StockRequisition[] @relation("ToRequisitions")

  @@unique([name, businessUnitId])
}

// Add this enum
enum StockRequisitionStatus {
  PENDING
  APPROVED
  FULFILLED // The items have been physically transferred
  REJECTED
}

// Add these new models
// Update your StockRequisition model
model StockRequisition {
  id                String                 @id @default(uuid())
  requisitionNumber String                 @unique
  fromLocationId    String
  fromLocation      InventoryLocation      @relation("FromRequisitions", fields: [fromLocationId], references: [id])
  toLocationId      String
  toLocation        InventoryLocation      @relation("ToRequisitions", fields: [toLocationId], references: [id])
  requestorId       String
  requestor         User                   @relation("UserRequests", fields: [requestorId], references: [id])
  fulfillerId       String?
  fulfiller         User?                  @relation("UserFulfills", fields: [fulfillerId], references: [id])
  status            StockRequisitionStatus @default(PENDING)
  notes             String?
  items             StockRequisitionItem[]
  createdAt         DateTime               @default(now())
  fulfilledAt       DateTime?
  stockMovements    InventoryMovement[]
}

model StockRequisitionItem {
  id                 String           @id @default(uuid())
  stockRequisitionId String
  stockRequisition   StockRequisition @relation(fields: [stockRequisitionId], references: [id], onDelete: Cascade)
  inventoryItemId    String
  inventoryItem      InventoryItem    @relation(fields: [inventoryItemId], references: [id])
  requestedQuantity  Float
  fulfilledQuantity  Float?
}

model Payment {
  id      String @id @default(uuid())
  orderId String
  order   Order  @relation(fields: [orderId], references: [id])
  amount  Float

  // The foreign key linking to the PaymentMethod model
  paymentMethodId String
  paymentMethod   PaymentMethod @relation(fields: [paymentMethodId], references: [id])

  paymentDate       DateTime @default(now())
  referenceNumber   String?
  processedByUserId String
  processedByUser   User     @relation(fields: [processedByUserId], references: [id])
  shiftId           String
  shift             Shift    @relation(fields: [shiftId], references: [id])
  createdAt         DateTime @default(now())
}

// CORRECTED: Model name is now PascalCase
model PaymentMethod {
  id          String    @id @default(uuid())
  name        String // e.g., "Cash", "Credit Card", "GCash"
  description String?
  isActive    Boolean   @default(true)
  payments    Payment[] // The back-relation is correct
}

enum KdsStatus {
  PENDING // Item is in the queue, not yet started.
  PREPARING // A chef is actively working on the item.
  READY // The item is finished and ready for pickup by a server.
}

model FinancialReport {
  id             String       @id @default(uuid())
  businessUnitId String
  businessUnit   BusinessUnit @relation(fields: [businessUnitId], references: [id])

  name     String // e.g., "Profit & Loss Statement", "Balance Sheet"
  periodId String // Links to your AccountingPeriod model
  period   AccountingPeriod @relation(fields: [periodId], references: [id])

  generatedAt DateTime @default(now())

  lines FinancialReportLine[]
}

model FinancialReportLine {
  id                String          @id @default(uuid())
  financialReportId String
  financialReport   FinancialReport @relation(fields: [financialReportId], references: [id])

  label String // e.g., "Total Sales Revenue", "Net Income"
  value Float
  order Int // To maintain the correct order of lines in the report
}
